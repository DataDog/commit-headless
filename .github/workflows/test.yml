# Integration tests for commit-headless action
name: Test

permissions:
  contents: write

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

    - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
      with:
        go-version: '1.24'

    - name: Run Go tests
      run: go test -v ./...

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests

    env:
      TEST_BRANCH: test/ci-${{ github.run_id }}

    steps:
    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        fetch-depth: 0

    - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
      with:
        go-version: '1.24'

    - name: Build action
      run: |
        mkdir -p ./action-template/dist
        go build -buildvcs=false -o ./action-template/dist/commit-headless-linux-amd64 .

    - name: Configure git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

    # Test: push command with multiple commits
    - name: "Test push: create local commits"
      run: |
        echo "First change" > test-file.txt
        git add test-file.txt
        git commit -m "test: first commit"

        echo "Second change" >> test-file.txt
        git add test-file.txt
        git commit -m "test: second commit"

    - name: "Test push: push commits to new branch"
      id: test-push
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        head-sha: ${{ github.sha }}
        create-branch: true
        command: push

    - name: "Test push: verify output"
      run: |
        if [ -z "${{ steps.test-push.outputs.pushed_ref }}" ]; then
          echo "ERROR: pushed_ref output is empty"
          exit 1
        fi
        echo "Pushed ref: ${{ steps.test-push.outputs.pushed_ref }}"

    - name: "Test push: verify commits on remote"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}

        # Check that both commits exist
        log=$(git log origin/${{ env.TEST_BRANCH }} --oneline -3)
        echo "Remote log:"
        echo "$log"

        if ! echo "$log" | grep -q "test: first commit"; then
          echo "ERROR: first commit not found on remote"
          exit 1
        fi
        if ! echo "$log" | grep -q "test: second commit"; then
          echo "ERROR: second commit not found on remote"
          exit 1
        fi

    # Test: push with no changes (should succeed with exit 0)
    # After API push, remote commits have different hashes than local commits,
    # so we need to sync local with remote first.
    - name: "Test push: sync local with remote"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}
        git reset --hard origin/${{ env.TEST_BRANCH }}

    - name: "Test push: no changes succeeds"
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        command: push

    # Test: commit command with staged changes
    - name: "Test commit: stage changes"
      run: |
        echo "Committed via commit command" > commit-test.txt
        git add commit-test.txt

    - name: "Test commit: push staged changes"
      id: test-commit
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        message: "test: commit command"
        command: commit

    - name: "Test commit: verify output"
      run: |
        if [ -z "${{ steps.test-commit.outputs.pushed_ref }}" ]; then
          echo "ERROR: pushed_ref output is empty"
          exit 1
        fi
        echo "Pushed ref: ${{ steps.test-commit.outputs.pushed_ref }}"

    - name: "Test commit: verify on remote"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}

        log=$(git log origin/${{ env.TEST_BRANCH }} --oneline -1)
        echo "Remote log:"
        echo "$log"

        if ! echo "$log" | grep -q "test: commit command"; then
          echo "ERROR: commit not found on remote"
          exit 1
        fi

    # Test: commit with no staged changes (should succeed with exit 0)
    - name: "Test commit: no staged changes succeeds"
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        message: "this should not appear"
        command: commit

    # Test: file mode preservation
    # Sync local with remote after commit command created new remote commits
    - name: "Test modes: sync local with remote"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}
        git reset --hard origin/${{ env.TEST_BRANCH }}

    - name: "Test modes: create executable"
      run: |
        echo '#!/bin/bash' > script.sh
        echo 'echo "Hello from script"' >> script.sh
        chmod +x script.sh
        git add script.sh
        git commit -m "test: add executable script"

    - name: "Test modes: push executable"
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        command: push

    - name: "Test modes: verify executable bit preserved"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}

        # Get the file mode from the remote
        mode=$(git ls-tree origin/${{ env.TEST_BRANCH }} -- script.sh | awk '{print $1}')
        echo "File mode on remote: $mode"

        if [ "$mode" != "100755" ]; then
          echo "ERROR: executable bit not preserved, expected 100755 got $mode"
          exit 1
        fi
        echo "Executable bit preserved successfully"

    # Test: replay command (re-sign existing commits)
    - name: "Test replay: sync and record base"
      id: replay-setup
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}
        git reset --hard origin/${{ env.TEST_BRANCH }}

        # Record the current HEAD as the base for replay
        echo "base_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

    - name: "Test replay: create commits with regular git push"
      run: |
        # Create commits that will be "unsigned" (pushed via git, not API)
        echo "replay test 1" > replay-test.txt
        git add replay-test.txt
        git commit -m "test: replay commit 1"

        echo "replay test 2" >> replay-test.txt
        git add replay-test.txt
        git commit -m "test: replay commit 2"

        # Push directly with git (these won't be signed)
        git push origin HEAD:${{ env.TEST_BRANCH }}

    - name: "Test replay: record pre-replay HEAD"
      id: pre-replay
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}
        echo "head_sha=$(git rev-parse origin/${{ env.TEST_BRANCH }})" >> $GITHUB_OUTPUT

    - name: "Test replay: replay commits as signed"
      id: test-replay
      uses: ./action-template
      with:
        branch: ${{ env.TEST_BRANCH }}
        since: ${{ steps.replay-setup.outputs.base_sha }}
        command: replay

    - name: "Test replay: verify output"
      run: |
        if [ -z "${{ steps.test-replay.outputs.pushed_ref }}" ]; then
          echo "ERROR: pushed_ref output is empty"
          exit 1
        fi
        echo "Pushed ref: ${{ steps.test-replay.outputs.pushed_ref }}"

    - name: "Test replay: verify commits were replayed"
      run: |
        git fetch origin ${{ env.TEST_BRANCH }}

        # The HEAD should be different (new signed commits)
        new_head=$(git rev-parse origin/${{ env.TEST_BRANCH }})
        old_head="${{ steps.pre-replay.outputs.head_sha }}"

        echo "Old HEAD: $old_head"
        echo "New HEAD: $new_head"

        if [ "$new_head" = "$old_head" ]; then
          echo "ERROR: HEAD unchanged after replay"
          exit 1
        fi

        # But the commit messages should still be there
        log=$(git log origin/${{ env.TEST_BRANCH }} --oneline -3)
        echo "Remote log:"
        echo "$log"

        if ! echo "$log" | grep -q "test: replay commit 1"; then
          echo "ERROR: replay commit 1 not found"
          exit 1
        fi
        if ! echo "$log" | grep -q "test: replay commit 2"; then
          echo "ERROR: replay commit 2 not found"
          exit 1
        fi

        echo "Replay test passed: commits were replayed with new hashes"

    # Cleanup: delete test branch
    - name: Cleanup test branch
      if: always()
      run: |
        git push origin --delete ${{ env.TEST_BRANCH }} || true
